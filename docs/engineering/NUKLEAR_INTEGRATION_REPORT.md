# Engineering Report: Nuklear UI Integration

**Report Date:** June 29, 2025
**Author:** Gemini
**Status:** Research & Analysis Complete

## 1. Executive Summary

This report details the investigation into the project's UI system as outlined in `docs/sprints/05_ui_integration.md`. A key finding is a technology mismatch: while the sprint plan specifies **Dear ImGui**, the actual codebase (`src/ui.c`, `src/nuklear.h`) implements the **Nuklear** immediate-mode GUI library.

The existing implementation is functional, demonstrating a successful integration of Nuklear with the Sokol framework via the `sokol_nuklear.h` header. This report provides a comprehensive overview of the Nuklear API, an analysis of the current integration, and a revised set of best practices and objectives to align the sprint goals with the implemented technology.

The recommendation is to formally adopt Nuklear and update the project documentation to reflect this decision. Nuklear is a lightweight, dependency-free, and highly portable C library, making it a suitable choice for this project's architecture.

## 2. Nuklear API and Sokol Integration

Nuklear is a single-header, immediate-mode GUI library written in C89. Unlike retained-mode libraries, it rebuilds the UI from scratch every frame. This approach offers simplicity and flexibility, fitting well with the architecture of game engines.

### 2.1. Core Concepts

- **Context (`struct nk_context`):** The central state manager for the UI. It tracks widget states, input, and drawing commands. In our project, it is initialized in `ui_init()` via `snk_setup()` and stored in the `ui_state` struct.

- **Immediate Mode UI Construction:** UI elements are declared within a `nk_begin()`/`nk_end()` block. These functions define a window, and all widget calls between them populate that window. The existing code demonstrates this with the "Debug Info" window in `ui_render()`.

- **Layout Management:** Nuklear provides functions to control the placement of widgets. The current implementation uses `nk_layout_row_dynamic()` to create rows of a specific height, with one widget per row. Other options include static layouts, template-based layouts, and more complex row structures.

- **Widget API:** Nuklear offers a rich set of widgets through functions like `nk_label()`, `nk_button_label()`, `nk_slider_float()`, etc. The return value of these functions typically indicates user interaction (e.g., `nk_button_label()` returns `true` if clicked).

- **Trees and Tabs:** The `nk_tree_push()`/`nk_tree_pop()` functions, as seen in `ui_render()`, create collapsible sections, which are excellent for organizing complex information in debug panels.

### 2.2. Sokol Integration via `sokol_nuklear.h`

The `sokol_nuklear.h` header is the bridge between Nuklear and the Sokol ecosystem.

- **Initialization (`snk_setup`):** This function, called in `ui_init()`, sets up the Nuklear context and configures the rendering backend to work with `sokol_gfx`.

- **Event Handling (`snk_handle_event`):** This is the most critical part of the integration. The main application's event callback must pass all `sapp_event`s to `snk_handle_event()`. This function translates Sokol's input events (mouse clicks, key presses, etc.) into a format Nuklear can understand. It returns `true` if the UI has "captured" the event, which should be used to prevent the game from processing input meant for the UI.

- **Rendering (`snk_render`):** After all UI elements for a frame have been declared, `snk_render()` is called. It takes the drawing commands generated by Nuklear and translates them into `sokol_gfx` render calls, drawing the UI on the screen.

## 3. Analysis of Current Implementation (`src/ui.c`)

The current `ui.c` provides a solid foundation.

- **Initialization/Shutdown:** `ui_init()` and `ui_shutdown()` correctly manage the Nuklear context.
- **Event Handling:** `ui_handle_event()` is correctly exposed to be called from the main event loop.
- **Rendering:** `ui_render()` successfully creates a movable, resizable debug window with dynamic labels and a collapsible tree view for entities.

**Areas for Improvement & Best Practices:**

1.  **Input Capturing:** The main event loop should check the return value of `ui_handle_event()`. If it's `true`, the game's own input processing (e.g., camera movement) should be skipped for that event.

2.  **State Management:** The current implementation passes the `World` pointer directly to `ui_render()`. For more complex UIs, consider creating a dedicated `UIState` struct to hold UI-specific data (e.g., `show_debug_panel`, slider values, etc.) This decouples the UI from the core game state.

3.  **HUD Implementation:** A non-interactive HUD can be created using a window with flags like `NK_WINDOW_NO_INPUT` and `NK_WINDOW_NO_HEADER`. This window would be positioned in a fixed corner of the screen.

4.  **Performance:** For UIs with a large number of elements, it's good practice to check the return value of `nk_begin()`. If a window is minimized or closed, `nk_begin()` returns `false`, and the widget declarations within it can be skipped for that frame, saving CPU cycles.

## 4. Revised Sprint Plan: Nuklear Integration

This revised plan aligns the original sprint goals with the Nuklear implementation.

**Goal:** Finalize the integration of Nuklear to create a flexible and powerful UI system, including a HUD and a comprehensive debug panel.

### Key Objectives:

1.  **Finalize Core Integration:**
    *   [ ] **Verify Input Handling:** Ensure the main event loop correctly uses the return value of `ui_handle_event()` to prevent input conflicts between the UI and the game.
    *   [ ] **Documentation:** Update all relevant project documents, including sprint plans and guides, to replace "Dear ImGui" with "Nuklear".

2.  **Create a Basic HUD:**
    *   [ ] **Design:** Design a simple, non-interactive HUD to display player/camera information (e.g., position, velocity).
    *   [ ] **Implement:** In `ui_render()`, create a new Nuklear window with the `NK_WINDOW_NO_INPUT` and `NK_WINDOW_NO_HEADER` flags. Position it in a screen corner and populate it with data from the `world` struct using `nk_label()` or `nk_labelf()`.

3.  **Expand the Debug Panel:**
    *   [ ] **Toggle Functionality:** Add a global boolean (e.g., `static bool show_debug_panel = true;`) that can be toggled with a key press or a button. The `nk_begin()` block for the debug panel should be conditional on this boolean.
    *   [ ] **Runtime Controls:** Add interactive widgets to the debug panel to modify game state at runtime.
        *   Use `nk_checkbox_label()` to toggle wireframe rendering.
        *   Use `nk_property_float()` or `nk_slider_float()` to adjust values like camera speed or lighting parameters.
    *   [ ] **Display FPS:** Add a label to display the current frames per second.

4.  **Refactor and Organize UI Code:**
    *   [ ] **UI State:** Consider creating a dedicated struct to manage the UI's state, as mentioned in the best practices.
    *   [ ] **Code Structure:** If the `ui_render` function becomes too large, break it down into smaller, static functions for each UI component (e.g., `draw_hud()`, `draw_debug_panel()`).

By following this revised plan, the team can leverage the existing Nuklear implementation to build a robust and well-integrated UI system that meets the project's needs.
