<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGame Mesh Viewer</title>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            height: 100vh;
            background-color: #1e1e1e;
            color: #fff;
        }
        #sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            background-color: #252526;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2);
        }
        #sidebar-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }
        #mesh-list-container {
            overflow-y: auto;
            flex-grow: 1;
            padding: 10px;
        }
        details {
            margin-bottom: 10px;
        }
        summary {
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            background-color: #3a3d41;
            display: block;
        }
        .folder-content {
            padding-left: 15px;
            border-left: 1px solid #444;
            margin-left: 8px;
            padding-top: 5px;
        }
        .mesh-item {
            padding: 8px 12px;
            margin: 2px 0;
            background-color: #3a3d41;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .mesh-item:hover {
            background-color: #4a4d51;
        }
        .mesh-item.selected {
            background-color: #0e639c;
        }
        #main-content {
            flex-grow: 1;
            position: relative;
        }
        #viewer-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        canvas { display: block; }
        .status-message {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            max-width: 300px;
            z-index: 1000;
            border-left: 4px solid #0e639c;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div id="sidebar-header">
            <h2>CGame Meshes</h2>
        </div>
        <div id="mesh-list-container"></div>
    </div>
    <div id="main-content">
        <div id="viewer-container"></div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OBJLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/OBJLoader.js';
        import { MTLLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/MTLLoader.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        let camera, scene, renderer, controls;
        const meshListContainer = document.getElementById('mesh-list-container');
        const viewerContainer = document.getElementById('viewer-container');
        const sourceAssetsRoot = '/assets/meshes/';

        async function fetchAndDisplayMeshes() {
            try {
                const indexResponse = await fetch(`${sourceAssetsRoot}index.json`);
                const meshIndex = await indexResponse.json();

                meshListContainer.innerHTML = '';
                const meshesByGroup = {};

                for (const metaPath of meshIndex) {
                    const fullMetaPath = `${sourceAssetsRoot}${metaPath}`;
                    const metaResponse = await fetch(fullMetaPath);
                    const meta = await metaResponse.json();
                    
                    const group = getDirectoryName(metaPath);
                    if (!meshesByGroup[group]) {
                        meshesByGroup[group] = [];
                    }

                    meshesByGroup[group].push({
                        meta,
                        basePath: `${sourceAssetsRoot}${group}/`
                    });
                }

                for (const groupName in meshesByGroup) {
                    const details = document.createElement('details');
                    details.open = true;
                    
                    const summary = document.createElement('summary');
                    summary.textContent = groupName;
                    details.appendChild(summary);

                    const folderContent = document.createElement('div');
                    folderContent.className = 'folder-content';

                    meshesByGroup[groupName].sort((a, b) => a.meta.name.localeCompare(b.meta.name));

                    for (const meshData of meshesByGroup[groupName]) {
                        const meshItem = createMeshListItem(meshData);
                        folderContent.appendChild(meshItem);
                    }
                    details.appendChild(folderContent);
                    meshListContainer.appendChild(details);
                }

            } catch (error) {
                console.error('Failed to load source mesh index:', error);
                meshListContainer.innerHTML = '<p style="color: #ff6b6b; padding: 15px;">Failed to load source assets. Ensure you are running a local web server from the project root.</p>';
            }
        }

        function getDirectoryName(path) {
            const lastSlash = path.lastIndexOf('/');
            return lastSlash === -1 ? '' : path.substring(0, lastSlash);
        }

        function createMeshListItem(meshData) {
            const { meta } = meshData;
            const listItem = document.createElement('div');
            listItem.className = 'mesh-item';
            
            listItem.innerHTML = `
                <div style="font-weight: 500;">📄 ${meta.name}</div>
                <div style="font-size: 12px; color: #888; margin-top: 2px;">
                    Source • ${meta.filename}
                </div>
            `;
            
            listItem.addEventListener('click', () => {
                document.querySelectorAll('.mesh-item').forEach(item => item.classList.remove('selected'));
                listItem.classList.add('selected');
                loadMesh(meshData);
            });
            
            return listItem;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e);

            camera = new THREE.PerspectiveCamera(75, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.1, 1000);
            camera.position.set(3, 3, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            viewerContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 3, 2);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);
            
            onWindowResize();
            fetchAndDisplayMeshes().then(() => {
                const firstMeshItem = document.querySelector('.mesh-item');
                if (firstMeshItem) {
                    firstMeshItem.click();
                }
            });
            animate();
        }

        async function loadMesh(meshData) {
            const { meta, basePath } = meshData;
            
            try {
                console.log(`Loading mesh: ${meta.name} from ${basePath}${meta.filename}`);
                
                const meshURL = `${basePath}${meta.filename}`;
                const meshText = await (await fetch(meshURL)).text();
                const objLoader = new OBJLoader();
                let object;

                try {
                    // Try loading with materials first
                    const mtlURL = `${basePath}${meta.mtl}`;
                    const mtlText = await (await fetch(mtlURL)).text();
                    const mtlLoader = new MTLLoader();
                    const materials = mtlLoader.parse(mtlText, basePath);
                    materials.preload();
                    objLoader.setMaterials(materials);
                    
                    object = objLoader.parse(meshText);
                    showMessage(`✅ Loaded: ${meta.name}`, `Source: ${meta.filename}`);

                } catch (materialError) {
                    console.warn(`Could not load materials for ${meta.name}, loading without:`, materialError);
                    // Fallback to loading without materials
                    object = objLoader.parse(meshText);
                    showMessage(`⚠️ Loaded without materials: ${meta.name}`, `Source: ${meta.filename} (MTL or texture failed)`);
                }

                // Apply transformations and add to scene
                object.traverse((child) => {
                    if (child.isMesh) {
                        if (!child.material) {
                             child.material = new THREE.MeshPhongMaterial({
                                color: 0xcccccc,
                                side: THREE.DoubleSide
                            });
                        }
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.side = THREE.DoubleSide);
                        } else {
                            child.material.side = THREE.DoubleSide;
                        }
                    }
                });
                
                clearScene();
                centerAndAddObject(object);

            } catch (error) {
                console.error(`Failed to load mesh: ${meta.name}`, error);
                showMessage(`❌ Failed to load: ${meta.name}`, `Error: ${error.message}`);
            }
        }

        function showMessage(title, details) {
            const existingMessage = document.querySelector('.status-message');
            if (existingMessage) existingMessage.remove();

            const message = document.createElement('div');
            message.className = 'status-message';
            message.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 4px;">${title}</div>
                <div style="font-size: 12px; opacity: 0.8;">${details}</div>
            `;
            viewerContainer.appendChild(message);
            
            setTimeout(() => message.remove(), 5000);
        }
        
        function clearScene() {
            const toRemove = [];
            scene.traverse(child => {
                if (child.isMesh || child.isGroup) toRemove.push(child);
            });
            toRemove.forEach(child => {
                scene.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => {
                            if (m.map) m.map.dispose();
                            m.dispose();
                        });
                    } else {
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                }
            });
        }

        function centerAndAddObject(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fitHeightDistance = maxDim / (2 * Math.atan(Math.PI * camera.fov / 360));
            const fitWidthDistance = fitHeightDistance / camera.aspect;
            const distance = Math.max(fitHeightDistance, fitWidthDistance);

            object.position.sub(center);
            scene.add(object);

            camera.position.copy(center);
            camera.position.z += distance * 1.2;
            camera.near = distance / 100;
            camera.far = distance * 100;
            camera.updateProjectionMatrix();

            controls.target.copy(center);
            controls.update();
        }

        function onWindowResize() {
            const { clientWidth, clientHeight } = viewerContainer;
            camera.aspect = clientWidth / clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(clientWidth, clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
