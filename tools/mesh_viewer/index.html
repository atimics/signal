<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGame Asset Viewer</title>
    <style>
        bo    <div id="sidebar">
        <div id="sidebar-header">
            <h2>CGame Asset Viewer</h2>
            <div id="mode-selector">
                <button class="mode-button active" data-mode="source">üìÑ Source Assets</button>
                <button class="mode-button" data-mode="compiled" disabled title="Binary assets cannot be viewed in browser">‚öôÔ∏è Compiled</button>
            </div>
            <div style="font-size: 11px; color: #888; margin-top: 8px;">
                View source OBJ files with UV layouts and textures. Compiled binary assets are used by the engine.
            </div>
        </div>          margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            height: 100vh;
            background-color: #1e1e1e;
            color: #fff;
        }
        #sidebar {
            width: 350px;
            display: flex;
            flex-direction: column;
            background-color: #252526;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2);
        }
        #sidebar-header {
            padding: 15px;
            border-bottom: 1px solid #333;
        }
        #mode-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .mode-button {
            flex: 1;
            padding: 8px 12px;
            background-color: #3a3d41;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        .mode-button:hover {
            background-color: #4a4d51;
        }
        .mode-button.active {
            background-color: #0e639c;
        }
        .mode-button:disabled {
            background-color: #2d2d30;
            color: #666;
            cursor: not-allowed;
        }
        #asset-info {
            padding: 10px 15px;
            background-color: #2d2d30;
            border-bottom: 1px solid #333;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        #mesh-list-container {
            overflow-y: auto;
            flex-grow: 1;
            padding: 10px;
        }
        details {
            margin-bottom: 10px;
        }
        summary {
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            background-color: #3a3d41;
            display: block;
        }
        .folder-content {
            padding-left: 15px;
            border-left: 1px solid #444;
            margin-left: 8px;
            padding-top: 5px;
        }
        .mesh-item {
            padding: 8px 12px;
            margin: 2px 0;
            background-color: #3a3d41;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .mesh-item:hover {
            background-color: #4a4d51;
        }
        .mesh-item.selected {
            background-color: #0e639c;
        }
        .tag {
            display: inline-block;
            background-color: #444;
            color: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 1px 2px;
        }
        .tag.priority-high {
            background-color: #d73a49;
        }
        .tag.priority-medium {
            background-color: #fb8500;
        }
        .tag.priority-low {
            background-color: #28a745;
        }
        .material-preview {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            display: inline-block;
            margin-right: 4px;
            border: 1px solid #555;
        }
        #main-content {
            flex-grow: 1;
            position: relative;
        }
        #viewer-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        canvas { display: block; }
        .status-message {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            max-width: 300px;
            z-index: 1000;
            border-left: 4px solid #0e639c;
        }
        .color-swatch {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            display: inline-block;
            margin-right: 4px;
            border: 1px solid #555;
            vertical-align: middle;
        }
        .info-section {
            margin-bottom: 12px;
        }
        .info-section h4 {
            margin: 0 0 4px 0;
            color: #0e639c;
            font-size: 11px;
            text-transform: uppercase;
        }
        #texture-viewer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 256px;
            height: 256px;
            background-color: #252526;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 1001;
            display: none; /* Initially hidden */
            flex-direction: column;
        }
        #texture-viewer-header {
            background-color: #3a3d41;
            color: #fff;
            padding: 8px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }
        #texture-viewer-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .info-section p {
            margin: 0;
            font-size: 11px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div id="sidebar-header">
            <h2>CGame Semantic Materials</h2>
            <div id="mode-selector">
                <button class="mode-button active" data-mode="source">Source</button>
                <button class="mode-button" data-mode="compiled">Compiled</button>
            </div>
        </div>
        <div id="asset-info"></div>
        <div id="mesh-list-container"></div>
    </div>
    <div id="main-content">
        <div id="viewer-container"></div>
        <div id="texture-viewer">
            <div id="texture-viewer-header">Texture Preview</div>
            <img id="texture-viewer-image" src="" alt="Texture"/>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OBJLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/OBJLoader.js';
        import { MTLLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/MTLLoader.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        let camera, scene, renderer, controls;
        let materialDefinitions = null;
        let currentMode = 'source';
        
        const meshListContainer = document.getElementById('mesh-list-container');
        const viewerContainer = document.getElementById('viewer-container');
        const assetInfo = document.getElementById('asset-info');
        const textureViewer = document.getElementById('texture-viewer');
        const textureViewerImage = document.getElementById('texture-viewer-image');
        const sourceAssetsRoot = '../../assets/meshes/';
        const compiledAssetsRoot = '../../build/assets/meshes/';

        // ... (rest of the script)

        function showTexture(texturePath) {
            textureViewerImage.src = texturePath;
            textureViewer.style.display = 'flex';
        }

        function hideTexture() {
            textureViewer.style.display = 'none';
        }

        // Load material definitions for tag analysis
        async function loadMaterialDefinitions() {
            try {
                const response = await fetch('../../assets/material_definitions.json');
                materialDefinitions = await response.json();
                console.log('Loaded material definitions:', materialDefinitions);
            } catch (error) {
                console.warn('Could not load material definitions:', error);
                materialDefinitions = { definitions: {} };
            }
        }

        // Get tag information including priority and colors
        function getTagInfo(tag) {
            const definition = materialDefinitions?.definitions?.[tag];
            if (!definition) {
                return {
                    priority: 0,
                    colors: { primary: '#888888' },
                    material: null,
                    description: 'Unknown tag'
                };
            }
            return definition;
        }

        // Get priority class for styling
        function getPriorityClass(priority) {
            if (priority >= 80) return 'priority-high';
            if (priority >= 40) return 'priority-medium';
            return 'priority-low';
        }

        // Mode switching
        document.getElementById('mode-selector').addEventListener('click', (e) => {
            if (e.target.classList.contains('mode-button')) {
                document.querySelectorAll('.mode-button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                currentMode = e.target.dataset.mode;
                fetchAndDisplayMeshes();
            }
        });

        async function fetchAndDisplayMeshes() {
            const assetsRoot = currentMode === 'source' ? sourceAssetsRoot : compiledAssetsRoot;
            
            try {
                const indexResponse = await fetch(`${assetsRoot}index.json`);
                const meshIndex = await indexResponse.json();

                meshListContainer.innerHTML = '';
                assetInfo.innerHTML = '';
                
                const meshesByGroup = {};

                for (const metaPath of meshIndex) {
                    const fullMetaPath = `${assetsRoot}${metaPath}`;
                    const metaResponse = await fetch(fullMetaPath);
                    const meta = await metaResponse.json();
                    
                    const group = getDirectoryName(metaPath);
                    if (!meshesByGroup[group]) {
                        meshesByGroup[group] = [];
                    }

                    meshesByGroup[group].push({
                        meta,
                        basePath: `${assetsRoot}${group}/`
                    });
                }

                for (const groupName in meshesByGroup) {
                    const details = document.createElement('details');
                    details.open = true;
                    
                    const summary = document.createElement('summary');
                    summary.textContent = groupName;
                    details.appendChild(summary);

                    const folderContent = document.createElement('div');
                    folderContent.className = 'folder-content';

                    meshesByGroup[groupName].sort((a, b) => a.meta.name.localeCompare(b.meta.name));

                    for (const meshData of meshesByGroup[groupName]) {
                        const meshItem = createMeshListItem(meshData);
                        folderContent.appendChild(meshItem);
                    }
                    details.appendChild(folderContent);
                    meshListContainer.appendChild(details);
                }

            } catch (error) {
                console.error(`Failed to load ${currentMode} mesh index:`, error);
                meshListContainer.innerHTML = `<p style="color: #ff6b6b; padding: 15px;">Failed to load ${currentMode} assets. Ensure you are running a local web server from the project root.</p>`;
            }
        }

        function getDirectoryName(path) {
            const lastSlash = path.lastIndexOf('/');
            return lastSlash === -1 ? '' : path.substring(0, lastSlash);
        }

        function createMeshListItem(meshData) {
            const { meta } = meshData;
            const listItem = document.createElement('div');
            listItem.className = 'mesh-item';
            
            // Get primary tag for color preview
            const primaryTag = meta.tags?.[0];
            const tagInfo = primaryTag ? getTagInfo(primaryTag) : null;
            const primaryColor = tagInfo?.colors?.primary || '#888888';
            
            // Create tags display
            const tagsHtml = meta.tags ? meta.tags.map(tag => {
                const info = getTagInfo(tag);
                const priorityClass = getPriorityClass(info.priority);
                return `<span class="tag ${priorityClass}" title="${info.description}">${tag}</span>`;
            }).join('') : '';
            
            const modeIcon = currentMode === 'source' ? 'üìÑ' : '‚öôÔ∏è';
            const fileExt = currentMode === 'source' ? 'mesh/obj' : 'cobj';
            
            listItem.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 4px;">
                    <div class="material-preview" style="background-color: ${primaryColor};" title="Primary tag color"></div>
                    <div style="font-weight: 500;">${modeIcon} ${meta.name}</div>
                </div>
                <div style="font-size: 12px; color: #888; margin-bottom: 4px;">
                    ${currentMode.charAt(0).toUpperCase() + currentMode.slice(1)} ‚Ä¢ ${fileExt}
                </div>
                <div>${tagsHtml}</div>
            `;
            
            listItem.addEventListener('click', () => {
                document.querySelectorAll('.mesh-item').forEach(item => item.classList.remove('selected'));
                listItem.classList.add('selected');
                updateAssetInfo(meshData);
                loadMesh(meshData);
            });
            
            return listItem;
        }

        function updateAssetInfo(meshData) {
            const { meta } = meshData;
            
            // Get semantic material info from tags
            const semanticInfo = analyzeSemanticMaterials(meta.tags || []);
            
            let infoHtml = `
                <div class="info-section">
                    <h4>Asset Info</h4>
                    <p><strong>${meta.name}</strong></p>
                    <p>${meta.description || 'No description'}</p>
                </div>
            `;
            
            if (meta.tags && meta.tags.length > 0) {
                infoHtml += `
                    <div class="info-section">
                        <h4>Tags & Materials</h4>
                `;
                
                meta.tags.forEach(tag => {
                    const info = getTagInfo(tag);
                    const priorityClass = getPriorityClass(info.priority);
                    infoHtml += `
                        <div style="margin-bottom: 6px;">
                            <div class="color-swatch" style="background-color: ${info.colors.primary}"></div>
                            <span class="tag ${priorityClass}">${tag}</span>
                            <span style="font-size: 10px; color: #999; margin-left: 4px;">P${info.priority}</span>
                        </div>
                        <p style="margin-left: 18px; color: #bbb; font-size: 10px;">${info.description}</p>
                    `;
                });
                
                infoHtml += '</div>';
            }
            
            if (semanticInfo.dominantTag) {
                const dominant = getTagInfo(semanticInfo.dominantTag);
                infoHtml += `
                    <div class="info-section">
                        <h4>Material Properties</h4>
                        <p><strong>Dominant:</strong> ${semanticInfo.dominantTag}</p>
                `;
                
                if (dominant.material) {
                    infoHtml += `
                        <p><strong>Ambient:</strong> RGB(${dominant.material.ambient.map(v => Math.round(v*255)).join(', ')})</p>
                        <p><strong>Diffuse:</strong> RGB(${dominant.material.diffuse.map(v => Math.round(v*255)).join(', ')})</p>
                        <p><strong>Specular:</strong> RGB(${dominant.material.specular.map(v => Math.round(v*255)).join(', ')})</p>
                        <p><strong>Shininess:</strong> ${dominant.material.shininess}</p>
                        ${dominant.material.emission ? `<p><strong>Emission:</strong> RGB(${dominant.material.emission.map(v => Math.round(v*255)).join(', ')})</p>` : ''}
                    `;
                }
                
                infoHtml += '</div>';
            }
            
            infoHtml += `
                <div class="info-section">
                    <h4>Files</h4>
                    <p><strong>Geometry:</strong> ${meta.geometry}</p>
                    <p><strong>Mesh:</strong> ${meta.mesh}</p>
                    <p><strong>Material:</strong> ${meta.material || 'N/A'}</p>
                    <p><strong>Texture:</strong> ${meta.texture || 'N/A'}</p>
                </div>
            `;
            
            assetInfo.innerHTML = infoHtml;
        }

        function analyzeSemanticMaterials(tags) {
            if (!tags || tags.length === 0) return { dominantTag: null };
            
            // Find the highest priority tag
            let dominantTag = tags[0];
            let highestPriority = getTagInfo(dominantTag).priority;
            
            for (const tag of tags) {
                const info = getTagInfo(tag);
                if (info.priority > highestPriority) {
                    highestPriority = info.priority;
                    dominantTag = tag;
                }
            }
            
            return { dominantTag };
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e);

            camera = new THREE.PerspectiveCamera(75, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.1, 1000);
            camera.position.set(3, 3, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            viewerContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 3, 2);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);
            
            onWindowResize();
            
            // Load material definitions first, then meshes
            loadMaterialDefinitions().then(() => {
                return fetchAndDisplayMeshes();
            }).then(() => {
                const firstMeshItem = document.querySelector('.mesh-item');
                if (firstMeshItem) {
                    firstMeshItem.click();
                }
            });
            
            animate();
        }

        async function loadMesh(meshData) {
            const { meta, basePath } = meshData;
            
            try {
                const isCompiled = currentMode === 'compiled';
                const meshFile = isCompiled ? meta.geometry : meta.mesh;
                console.log(`Loading mesh: ${meta.name} from ${basePath}${meshFile}`);
                
                const meshURL = `${basePath}${meshFile}`;
                
                const meshText = await (await fetch(meshURL)).text();
                const objLoader = new OBJLoader();
                let object;

                try {
                    // Try loading with materials first
                    const mtlURL = `${basePath}${meta.material}`;
                    const mtlText = await (await fetch(mtlURL)).text();
                    const mtlLoader = new MTLLoader();
                    
                    // Set base path for texture loading
                    mtlLoader.setResourcePath(basePath);
                    const materials = mtlLoader.parse(mtlText, basePath);
                    materials.preload();
                    objLoader.setMaterials(materials);
                    
                    object = objLoader.parse(meshText);
                    
                    const semanticInfo = analyzeSemanticMaterials(meta.tags || []);
                    const modeLabel = currentMode === 'source' ? 'Source' : 'Compiled';
                    showMessage(`‚úÖ Loaded: ${meta.name}`, `${modeLabel}: ${meshFile} ‚Ä¢ Semantic: ${semanticInfo.dominantTag || 'none'}`);

                } catch (materialError) {
                    console.warn(`Could not load materials for ${meta.name}, loading without:`, materialError);
                    // Fallback to loading without materials
                    object = objLoader.parse(meshText);
                    showMessage(`‚ö†Ô∏è Loaded without materials: ${meta.name}`, `${currentMode}: ${meshFile} (MTL or texture failed)`);
                }

                // Apply transformations and add to scene
                object.traverse((child) => {
                    if (child.isMesh) {
                        if (!child.material) {
                             child.material = new THREE.MeshPhongMaterial({
                                color: 0xcccccc,
                                side: THREE.DoubleSide
                            });
                        }
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.side = THREE.DoubleSide);
                        } else {
                            child.material.side = THREE.DoubleSide;
                        }
                    }
                });
                
                clearScene();
                centerAndAddObject(object);

                // Show the texture
                const texturePath = `${basePath}${meta.texture}`;
                showTexture(texturePath);

            } catch (error) {
                console.error(`Failed to load mesh: ${meta.name}`, error);
                showMessage(`‚ùå Failed to load: ${meta.name}`, `Error: ${error.message}`);
                hideTexture();
            }
        }

        function showMessage(title, details) {
            const existingMessage = document.querySelector('.status-message');
            if (existingMessage) existingMessage.remove();

            const message = document.createElement('div');
            message.className = 'status-message';
            message.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 4px;">${title}</div>
                <div style="font-size: 12px; opacity: 0.8;">${details}</div>
            `;
            viewerContainer.appendChild(message);
            
            setTimeout(() => message.remove(), 5000);
        }
        
        function clearScene() {
            hideTexture();
            const toRemove = [];
            scene.traverse(child => {
                if (child.isMesh || child.isGroup) toRemove.push(child);
            });
            toRemove.forEach(child => {
                scene.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => {
                            if (m.map) m.map.dispose();
                            m.dispose();
                        });
                    } else {
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                }
            });
        }

        function centerAndAddObject(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fitHeightDistance = maxDim / (2 * Math.atan(Math.PI * camera.fov / 360));
            const fitWidthDistance = fitHeightDistance / camera.aspect;
            const distance = Math.max(fitHeightDistance, fitWidthDistance);

            object.position.sub(center);
            scene.add(object);

            camera.position.copy(center);
            camera.position.z += distance * 1.2;
            camera.near = distance / 100;
            camera.far = distance * 100;
            camera.updateProjectionMatrix();

            controls.target.copy(center);
            controls.update();
        }

        function onWindowResize() {
            const { clientWidth, clientHeight } = viewerContainer;
            camera.aspect = clientWidth / clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(clientWidth, clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
