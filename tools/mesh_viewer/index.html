<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh Viewer & Data Pipeline</title>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            height: 100vh;
            background-color: #1e1e1e;
            color: #fff;
        }
        #sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            background-color: #252526;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2);
        }
        #sidebar-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }
        #mesh-list-container {
            overflow-y: auto;
            flex-grow: 1;
            padding: 10px;
        }
        details {
            margin-bottom: 10px;
        }
        summary {
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            background-color: #3a3d41;
            display: block;
        }
        .folder-content {
            padding-left: 15px;
            border-left: 1px solid #444;
            margin-left: 8px;
            padding-top: 5px;
        }
        .mesh-item {
            display: flex;
            align-items: center;
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            margin-bottom: 8px;
            transition: background-color 0.2s;
        }
        .mesh-item:hover, .mesh-item.active {
            background-color: #3a3d41;
        }
        .thumbnail {
            width: 40px;
            height: 40px;
            margin-right: 12px;
            background-color: #333;
            border: 1px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            flex-shrink: 0;
        }
        .thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .mesh-info {
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        .mesh-name {
            font-weight: 600;
        }
        .mesh-tags {
            font-size: 0.8em;
            color: #888;
        }
        #main-content {
            flex-grow: 1;
        }
        #viewer-container {
            height: 100%;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="sidebar">
        <div id="sidebar-header">
            <h2>Meshes</h2>
        </div>
        <div id="mesh-list-container"></div>
    </div>
    <div id="main-content">
        <div id="viewer-container"></div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OBJLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/OBJLoader.js';
        import { MTLLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/MTLLoader.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        let camera, scene, renderer, controls;
        const meshListContainer = document.getElementById('mesh-list-container');
        const viewerContainer = document.getElementById('viewer-container');
        const rootAssetsPath = '../../assets/meshes/';

        async function fetchAndDisplayMeshes() {
            try {
                const metaResponse = await fetch(`${rootAssetsPath}metadata.json`);
                const metadata = await metaResponse.json();

                meshListContainer.innerHTML = '';
                for (const group of metadata) {
                    const folderName = group.folder;
                    const meshes = group.meshes;

                    const details = document.createElement('details');
                    details.open = true;
                    
                    const summary = document.createElement('summary');
                    summary.textContent = folderName;
                    details.appendChild(summary);

                    const folderContent = document.createElement('div');
                    folderContent.className = 'folder-content';

                    for (const meshFile in meshes) {
                        const meta = meshes[meshFile];
                        const meshItem = createMeshListItem(folderName, meshFile, meta);
                        folderContent.appendChild(meshItem);
                    }
                    details.appendChild(folderContent);
                    meshListContainer.appendChild(details);
                }
            } catch (e) {
                console.error("Fatal: Could not load or parse metadata.json.", e);
                alert("Could not load metadata.json. The application cannot start.");
            }
        }

        function createMeshListItem(folder, file, meta) {
            const listItem = document.createElement('div');
            listItem.className = 'mesh-item';
            listItem.dataset.folder = folder;
            listItem.dataset.file = file;

            const thumb = document.createElement('div');
            thumb.className = 'thumbnail';
            const thumbImg = document.createElement('img');
            
            const textureFile = meta.texture || file.replace(/\.obj$/, '.png');
            thumbImg.src = `${rootAssetsPath}${folder}/${textureFile}`;
            thumbImg.onerror = () => { thumb.innerHTML = 'N/A'; };
            thumb.appendChild(thumbImg);

            const info = document.createElement('div');
            info.className = 'mesh-info';
            const nameEl = document.createElement('div');
            nameEl.className = 'mesh-name';
            nameEl.textContent = meta.name;
            const tagsEl = document.createElement('div');
            tagsEl.className = 'mesh-tags';
            tagsEl.textContent = (meta.tags || []).join(', ');
            info.appendChild(nameEl);
            info.appendChild(tagsEl);

            listItem.append(thumb, info);

            listItem.addEventListener('click', () => {
                document.querySelectorAll('.mesh-item').forEach(item => item.classList.remove('active'));
                listItem.classList.add('active');
                loadMesh(folder, file, meta);
            });
            
            return listItem;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e);

            camera = new THREE.PerspectiveCamera(75, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.1, 1000);
            camera.position.set(3, 3, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            viewerContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 3, 2);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);
            
            onWindowResize();
            fetchAndDisplayMeshes().then(() => {
                const sunMeshItem = document.querySelector('[data-file="sun.obj"]');
                if (sunMeshItem) {
                    sunMeshItem.click();
                }
            });
            animate();
        }

        async function loadMesh(folder, file, meta) {
            try {
                const assetPath = `${rootAssetsPath}${folder}/`;
                
                // 1. Always load the geometry first
                const objLoader = new OBJLoader();
                objLoader.setPath(assetPath);
                const object = await objLoader.loadAsync(file);

                // 2. Determine the material
                let material;
                if (meta.texture) {
                    // If texture is defined in metadata, create a basic textured material
                    console.log(`Found texture for ${file}, creating MeshBasicMaterial.`);
                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.setPath(assetPath);
                    const texture = await textureLoader.loadAsync(meta.texture);
                    
                    material = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        side: THREE.DoubleSide // Use DoubleSide to prevent issues with normals
                    });
                } else {
                    // If no texture, create a default lit material
                    console.log(`No texture found for ${file}, creating default MeshPhongMaterial.`);
                    material = new THREE.MeshPhongMaterial({
                        color: 0xcccccc,
                        side: THREE.DoubleSide
                    });
                }

                // 3. Apply the material to the object
                object.traverse((child) => {
                    if (child.isMesh) {
                        child.material = material;
                    }
                });
                
                clearScene();
                centerAndAddObject(object);

            } catch (error) {
                console.error(`Could not load mesh: ${file}`, error);
                clearScene();
            }
        }
        
        function clearScene() {
            const toRemove = scene.children.filter(child => child.isMesh || child.isGroup);
            toRemove.forEach(child => scene.remove(child));
        }

        function centerAndAddObject(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            object.position.sub(center);
            scene.add(object);
        }

        function onWindowResize() {
            const { clientWidth, clientHeight } = viewerContainer;
            camera.aspect = clientWidth / clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(clientWidth, clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>